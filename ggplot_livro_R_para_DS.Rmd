---
title: "GGPLOT2 - Livro R para DS"
author: "Ednei"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document:
      highlight: textmate # destaque nos codigos
      number_sections: no  # insere numeracao automatica nas secoes
      toc: yes # insere um tabela de conteudos/titulos
      toc_float:  # posiciona a tabela de titulos a esquerda
        collapsed: no
---

```{r setup, include=FALSE}
library(dplyr)
library(ggplot2)
```

## O dataframe mpg

O dataframe apresenta as seguintes variáveis:  
manufacturer - 15 manufacturers
model - 38 models  
* displ - displacement in liters 	1.6 - 7.0, median: 3.3  
* year - year of manufacturing 	1999, 2008  
* cyl - number of cylinders 	4, 5, 6, 8  
* trans - type of transmission 	automatic, manual (many sub types)  
* drv - drive type 	f, r, 4, f=front wheel, r=rear wheel, 4=4 wheel  
* cty - city mileage 	miles per gallon  
* hwy - highway mileage 	miles per gallon   
* fl - fuel type 	5 fuel types (diesel, petrol, electric, etc.)  
* class - vehicle class 	7 types (compact, SUV, minivan etc.)  


```{r mpg}
summary(mpg)

glimpse(mpg)
```

## Criand Gráficos com GGPLOT2

O gráfico abaixo mostra a relação entre o tamanho do motor e o consumo na estrada e, além disso, os veículos são diferenciados pela classe.
Outras opções para diferenciarmos a classe dos veículos seria utilizar size, alpha ou shape para mapear a classe dos veículos.

```{r echo=FALSE}
ggplot( data =mpg)+
  geom_point(mapping = aes( x= displ, y = hwy, colour = class))
```

Podemos também *mapear* as características fora da função aes e, neste caso, não acontecerá a transmissão de informação apenas uma estilização do gráfico. Por exemplo, podemos deixar todos os pontso do gráfico acima da mesma cor (colour), tamanho (size) ou formato (shape).

```{r}
ggplot( data =mpg)+
  geom_point(mapping = aes( x= displ, y = hwy), size = 3, colour='blue')
```
## Utilizando facetas

Facetas são uma maneira de incluir outras variáveis, particularmente categóricas nas análises. Além disso, elas também permitem visualizar os dados desagregados por cada categoria.
Para isso usamos a função facet_wrap e precisamos passar um fórmula que inicia com um ~ e depois acrescentamos o nome da variável.

```{r}
ggplot( data =mpg)+
  geom_point(mapping = aes( x= displ, y = hwy, colour = class))+
  facet_wrap(~ class, nrow = 2)
```

Podemos também criar facetas combinado duas variáveis usando facet_grid. No gráfico abaixo dividimos os veículos pelo número de cilindros e pelo tipo de tração e depois se indica a relação entre o consumo na estrado e o tamanho do motor.
Se não for conveniente criar facetas em uma das orientações (horizontal ou vertical), basta usar . na fórmula. Por exemplo, . ~ cyl ou então drv ~ ..

```{r}
ggplot( data =mpg)+
  geom_point(mapping = aes( x= displ, y = hwy, colour = class))+
  facet_grid(drv ~ cyl)
```

Os gráficos de linhas são  muito uteis para representar variáveis contínuas e também para permitir a visualização de tendências mais facilmente. 
Note no código abaixo que diferente dos anteriores as variáveis displ e hwy não estão na camada da geometria mas na camada principal do comando ggplot, isso indica que neste caso elas são globais e afetam todo o gráfico, já quando a função aes, or exemplo, está localizada na camada geom é tem efeito local e afeta apenas aquela camada.
Também no gráfico abaixo pode-se observar o efeito da função geom_smooth que acrescenta um curva que aproxima uma curva de regressão. Pode-se suprimir a parte achurada que indica o erro padrão acrescentando se = FALSE e também é possível especificar o método da regressão no parâmetro method, sendo o lm (linear model) o padrão.

```{r}
ggplot(data = mpg, mapping = aes(x= displ, y= hwy))+
  geom_point(mapping = aes(colour = class))+
  geom_smooth()
```

Uma possivibilidade bastante interssante que o uso de diferentes geometrias traz é que podemos mapear inclusiva dados diferentes para representá-los no mesmo gráfico.
No caso do gráfico abaixo se utiliza os mesmos pontos do anterior mas a curva apresentada leva em consideração apenas os valores das variáveis para os veículos compactos.

```{r}
ggplot(data = mpg, mapping = aes(x= displ, y= hwy))+
  geom_point(mapping = aes(colour = class))+
  geom_smooth(data = filter(mpg, class == 'compact'), se = FALSE)
```

## Transformações Estatísticas e Gráficos de Colunas

Usaremos nos próximos gráficos o conjunto de dados *diamonds* que acompanha o ggplot2.

```{r diamonds}

glimpse(diamonds)

```
Vamos iniciar com um gráfico de colunas simples quantificando a quantidade de diamantes em cada categoria de corte.

Observe no gráfico que será gerado que não indicamos a quantidade, somente a variável categórica que será representada no eixo x. Acontece que a função geom_bar contou a quantidade gerando um novo valor que foi representado no gráfico. Isso também acontece com histogramas e polígonos de frequência.
Por outro lado smothiers ajustam modelos aos dados representados graficamente.

```{r}
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut))
```
O algorítimo que fez a contagem é chamado de *stat* que é uma abreviação de estatística. No caso da função geom_bar ela tem duas estatísticas diferentes: count e prop. Como os nomes sugerem a primeira conta as ocorrências e a segunda representa os percentuais. 

```{r}
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, y= ..prop.., group = 1))
```

Os gráficos de colunas também podem ser coloridos manualmente ou então associando uma variável a um parâmetro. O parãmetro colour altera apenas a cor de contorno das colunas e o parâmetro fill altera o preenchimento.

```{r}
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, fill = cut))
```

Uma variação interessante é acrescentar uma outr variável a análise. Por exemplo, *clarity* e, neste caso note que as colunas apareceram emplilhadas pelo nível de transparência dos diamantes.

```{r}
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, fill= clarity))
```

Podemos alterar a forma como as colunas são organizadas alterndo o parâmetro position. As opções disponiveis são: dodge (coloca os objetos lado a lado); fill ( emplinha mas padroniza o tamanho das colunas, sendo bom para comparar proporções); idendity (coloca cada objeto no seu lugar, no contexto do gráfico).
Existe uma outra posição chamada de jitter que não é util com gráficos de barras mas que pode ser util com gráficos de pontos/dispersão pois evita a sobreposição de pontos.

```{r}
par(mfrow= c(1,3))
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, fill= clarity), position = 'identity')

ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, fill= clarity), position = 'dodge')

ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, fill= clarity), position= 'fill')
```

Para alterar os sistemas de coordenadas as duas funções mais importantes são coord_flip que troca as posições dos eixos x e y no sistema cartesiano, que é o sistema padrão do R e a função coord_polar que altera a representação para coordenadas no sistema polar.

```{r}
ggplot(data = diamonds)+
  geom_bar(mapping = aes(x= cut, fill = cut), show.legend = FALSE, width = 1)+
  theme(aspect.ratio = 1)+  # delimita uma proporção quadrada 1:1
  labs(x=NULL, y=NULL)+    # remove os eixos
  coord_polar()
```


